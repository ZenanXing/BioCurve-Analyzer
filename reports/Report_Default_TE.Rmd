---
title: "The T~50~ Estimation Report"
output: 
 html_document:
   code_folding: show
   toc: true
   toc_float:
     collapsed: false
     smooth_scroll: false
params:
  table: NA
  unit: NA
  min_time: NA
  t50_type: NA
  n_var: NA
  color_var: NA
  T50_related: NA
  Bestfit_dataframe: NA
  ScatterPlot_dataframe: NA
  Mean_SD_dataframe: NA
  plot_ed50_ck_te: NA
  plot_resline_ck_te: NA
  plot_ci_ck_te: NA
  facet_var_row: NA
  facet_var_col: NA
  legend_order: NA

---
<style type="text/css">
div.main-container {
  width: 100%;
  max-width: unset;
}

body, td {
   font-size: 18px;
}
code.r{
  font-size: 14px;
}
pre {
  font-size: 14px
}
</style>


This report is used for generating the dose response curves. You can customize the plots by modifying the codes. Just make sure that you have downloaded the dataframes (the excel file) used for plotting.

### Load the required packages
The packages used for plotting are listed below, load these packages before you run the codes.

```{r message = FALSE, warning = FALSE}
library(tidyverse)
library(ggplot2)
library(drcte)
library(drc)
library(ggthemes)
library(cowplot)
library(extrafont)
library(ggpubr)
library(openxlsx)
library(rmarkdown)
```

### T~50~ Tables
The T~50~s estimated by the app are listed below.
```{r echo = FALSE, results='asis'}
kable(params$table, format = "html") %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F, position = "left")
```


### Time-to-event Curve
The time-to-event curve is generated by the following codes. You can further customize the plot by modifying the codes. The following items are input variables passed from the app, please change following variables to their corresponding values listed below.  
  
* Variables  
   + `n_var`: `r params$n_var`  
   + `unit`: `r params$unit`  
   + `min_time`: `r params$min_time`  
   + `color_var`: `r params$color_var`  
   + `plot_ed50_ck_te`: `r params$plot_ed50_ck_te`  
   + `plot_resline_ck_te`: `r params$plot_resline_ck_te`  
   + `plot_ci_ck_te`: `r params$plot_ci_ck_te`  
   + `facet_var_row`: `r params$facet_var_row`  
   + `facet_var_col`: `r params$facet_var_col`  
   + `legend_order`: `r params$legend_order`  

* Dataframes  
   + `T50_related`: dataframe in "**T50_related**"  
   + `bestfit_dataframe`: dataframe in "**Bestfit_dataframe**"  
   + `scatterplot_dataframe`: dataframe in "**ScatterPlot_dataframe**"  
   + `Mean_dataframe`: dataframe in "**Mean_dataframe**"  


```{r message = FALSE, warning = FALSE}
# Passing variables from the app to the report

# Number of variables
n_var <- params$n_var 

# Unit of time
unit <- params$unit

# Minimum time point
min_time <- params$min_time

# Type of T50
t50_type <- params$t50_type

# Variables for assigning line color, row & column of facet plot
color_var <- params$color_var 
facet_var_row <- params$facet_var_row
facet_var_col <- params$facet_var_col

# Legend order
legend_order <- params$legend_order

# Show the T50-related lines
plot_ed50_ck_te <- params$plot_ed50_ck_te
plot_resline_ck_te <- params$plot_resline_ck_te
plot_ci_ck_te <- params$plot_ci_ck_te

# Dataframes
T50_related <- params$T50_related
bestfit_dataframe <- params$Bestfit_dataframe
scatterplot_dataframe <- params$ScatterPlot_dataframe
mean_sd_dataframe <- params$Mean_SD_dataframe

#' I used the dataframes passing from the app, if you want to use the code you should upload the dataframes stored in the excel file by the following codes.
#' Note: Remember to add the file path and remove the pound sign before you run the following codes.
# T50_related <- read.xlsx("ExportedExcel.xlsx", sheet = 1)
# bestfit_dataframe <- read.xlsx("ExportedExcel.xlsx", sheet = 2)
# scatterplot_dataframe <- read.xlsx("ExportedExcel.xlsx", sheet = 3)
# mean_sd_dataframe <- read.xlsx("ExportedExcel.xlsx", sheet = 4)

# Annotation dataframe
colnames(T50_related)[(n_var+1):ncol(T50_related)]<- c("Model", "Maximum_Response", "Minimum_Response", "Response_at_T50", 
                                                       "T50", "T50_SE", "T50_SD", "T50_LowerBound", "T50_UpperBound")
T50_related[, (n_var+2):ncol(T50_related)] <- lapply(T50_related[, (n_var+2):ncol(T50_related)], as.numeric)

# Modify the dataframes fo both of the minimum and maximum dose are valid:
## change the minimum dose according to the model type.
if (all(!T50_related$Model %in% c("NPMLE", "KDE"))) {
  scatterplot_dataframe$After[scatterplot_dataframe$After == 0] <- min_time
  bestfit_dataframe$After[bestfit_dataframe$After == 0] <- min_time
}

## change the maxmimum dose according to T50 type
if(t50_type == "Absolute" && all(T50_related$Model == "NPMLE")) {
  scatterplot_dataframe <- scatterplot_dataframe
} else {
  scatterplot_dataframe <- scatterplot_dataframe %>% filter(!is.infinite(After))
}

# Palette
cbPalette <- c("#00A4FF", "#FD7FEE", "#03DFCA", "#990A3A", "#F37B63", "#05B756", "#A3FB86", "#097C91", "#015EC9","#840EAA")

# Final plot
if (n_var == 0) {
  # color
  clr <- get_palette(cbPalette, 1)
  # plot
  p <- ggplot(data = bestfit_dataframe, aes(x = After, y = Response)) + 
    geom_line(color = clr) + 
    geom_point(data = scatterplot_dataframe, aes(x = After, y = Response), alpha = 0.5, color = clr)
  # T50
  if (plot_ed50_ck_te == TRUE) {
    p <- p +
      # response lines
      geom_hline(data = T50_related, aes(yintercept = Response_at_T50), linetype = "longdash", alpha = 0.5, color = clr) + 
      # ed lines
      geom_vline(data = T50_related, aes(xintercept = T50), linetype = "longdash", alpha = 0.5, color = clr)
    if (plot_ci_ck_te == TRUE) {
      p <- p +
        # et ci lines
        geom_vline(data = T50_related, aes(xintercept = T50_LowerBound), linetype = "dotted", alpha = 0.5, color = clr) + 
        geom_vline(data = T50_related, aes(xintercept = T50_UpperBound), linetype = "dotted", alpha = 0.5, color = clr)
    }
  }
  # Max & Min
  if (plot_resline_ck_te == TRUE) {
    p <- p +
      # response lines
      geom_hline(data = T50_related, aes(yintercept = Maximum_Response), linetype = "longdash", alpha = 0.5, color = clr) + 
      geom_hline(data = T50_related, aes(yintercept = Minimum_Response), linetype = "longdash", alpha = 0.5, color = clr)
  }
  # Add grey area
  if (all(T50_related$Model == "NPMLE")) {
    p <- p + 
      geom_rect(data = mean_sd_dataframe, aes(xmin = Before, xmax = After, ymin = Ymin, ymax = Ymax), fill = clr, inherit.aes = FALSE, alpha = 0.3)
  }
  
} else {
  # color
  n_color <- n_distinct(scatterplot_dataframe[[color_var]])
  # plot
  p <- ggplot(data = bestfit_dataframe, aes(x = After, y = Response, color = eval(parse(text = color_var)), 
                                           group = eval(parse(text = color_var)))) + 
    geom_line() + 
    geom_point(data = scatterplot_dataframe, aes(x = After, y = Response, group = eval(parse(text = color_var))), alpha = 0.5) +
    scale_color_manual(color_var, values = get_palette(cbPalette, n_color), limits = legend_order)
  # T50
  if (plot_ed50_ck_te == TRUE) {
    p <- p +
      # response lines
      geom_hline(data = T50_related, aes(yintercept = Response_at_T50, 
                                         group = eval(parse(text = color_var)), 
                                         color = eval(parse(text = color_var))), 
                 linetype = "longdash", alpha = 0.5) + 
      # ed lines
      geom_vline(data = T50_related, aes(xintercept = T50, 
                                         group = eval(parse(text = color_var)), 
                                         color = eval(parse(text = color_var))), 
                 linetype = "longdash", alpha = 0.5)
    if (plot_ci_ck_te == TRUE) {
      p <- p +
        # ed lines - left
        geom_vline(data = T50_related, aes(xintercept = T50_LowerBound, 
                                           group = eval(parse(text = color_var)), 
                                           color = eval(parse(text = color_var))), 
                   linetype = "dotted", alpha = 0.5) + 
        geom_vline(data = T50_related, aes(xintercept = T50_UpperBound, 
                                           group = eval(parse(text = color_var)), 
                                           color = eval(parse(text = color_var))), 
                   linetype = "dotted", alpha = 0.5)
    }
  }
  # Max & Min
  if (plot_resline_ck_te == TRUE) {
    p <- p +
      # response lines
      geom_hline(data = T50_related, aes(yintercept = Maximum_Response, 
                                         group = eval(parse(text = color_var)), 
                                         color = eval(parse(text = color_var))), 
                 linetype = "longdash", alpha = 0.5) + 
      geom_hline(data = T50_related, aes(yintercept = Minimum_Response, 
                                         group = eval(parse(text = color_var)), 
                                         color = eval(parse(text = color_var))), 
                 linetype = "longdash", alpha = 0.5)
  }
  # Add grey area
  if (all(T50_related$Model == "NPMLE")) {
    p <- p + 
      geom_rect(data = mean_sd_dataframe, 
                aes(xmin = Before, xmax = After, 
                    ymin = Ymin, ymax = Ymax, 
                    fill = eval(parse(text = color_var))), 
                inherit.aes = FALSE, alpha = 0.3, show.legend = FALSE) +
      scale_fill_manual(color_var, values = get_palette(cbPalette, n_color), limits = legend_order) + 
      labs(color = color_var)
  }
  
}

if (n_var >= 3) {
  p <- p +
    # facet_grid
    facet_grid(eval(parse(text = paste0(facet_var_row, "~", facet_var_col))))
} else {
  if (n_var > 1){
    p <- p +
      # facet_wrap
      facet_wrap(eval(parse(text = paste0(facet_var_row, "~", facet_var_col))), ncol = 4)
  }
}


# log transform the plot
if (all(!T50_related$Model %in% c("NPMLE", "KDE"))) {
  p <- p + scale_x_log10()
}


p <- p + 
  scale_y_continuous(labels = scales::percent) +
  xlab(paste0("Time (", unit, ")")) + 
  ylab("Rate to Event") +
  theme_few() +
  panel_border(colour = "black", size = 1, remove = FALSE) +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        strip.text = element_text(size = 18),
        legend.text = element_text(size = 18),
        legend.title = element_text(size = 18))
  

```

```{r message = FALSE, warning = FALSE, echo = FALSE, out.width = '100%', fig.align = "center"}
p
```

